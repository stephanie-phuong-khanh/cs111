------------------------
MEMORY MANAGEMENT
------------------------

- Memory abstracitons must be usable from a running program 
    - Modern machines -> RAM 

Goals 
- Transparency 
    - Process sees only own address space, unaware that memory is being shared 
- Efficiency 
    - Effective memory utiliziation, low run-time cost for allocation/relocation 
- Protection and isolation 
    - Private data will not be corrupted, cannot be seen by other processes 

Physical memory allocation 
[SEE IMAGE: physical_memory.png]

Physical and virtual addresses 
- a RAM cell has prticular physical address because RAM is a chip attached to the bus 
    - this physical address used to be used by processes to name memory locations 
- now processes use virtual addresses that are not a location on a memory chip and usually isn't the same as the actual physical address 
    - flexible but needs virtual to physical translation 
    - software that allows virtual thing to behave as if it were real (usually OS software) -> how to make virtual memory act real? 

Memory management problems 
- Most processes can't predict perfectly how much memory it'll use 
- Process expects to find its existing data when they need it where they left it 
- Entire data amount needed by all processes may be more than available physical memory 
- Switching b/w processes must be fast -> can't afford much delay for copying data 
- Cost of memory management itself must not be too high 

Some ideas..

Fixed partition allocations 
- n processes running -> reserve space for largest possible process 
- partitions come in one or a few set sizes 
- easy to implement: common in old batch processing systems, (de)allocation very cheap and easy 
- well suited to well known job mix 

Memory protection and fixed PARTITIONS 
- Need to enforce partition boundaries to prevent one process from accessing another's memory 
- Could use hardware for this with special registers that contain the partition boundares and we only accept addresses within the register values 
- Basic scheme doesn't use virtual addresses 

[SEE IMAGE: partition.png]
    done in hw 
    partition registers point to beginning or end 

Issues with fixed partition allocation 
- Presumes you know how much memory will be used ahead of time 
- Limits number of processes supported to the total of their memory requirements
- Not great for sharing memory 
- Framentation causes inefficient memory use 
- Simple, inflexible, possible option for special purpose systems (embedded) or if we know exactly what our memory needs will be

Fragmentation [SEE IMAGE: fragmentation.png]
- Internal fragmentation - wasted space inside fixed size blocks
    - Requestor given more than he needed -> unused part is wasted, can't be given to others 
    - Occurs when you force allocation in fixed-size chunks
    - Mismatch between chosen size of a fixed-sized block and actual sizes that programs use
    - Average waste: 50% of each block

Dynamic partition allocation 
- Still use partition registers, but... partitions
    - Variable sized, usually almost any size can be requested 
    - Each partition has contiguous memory addresses 
    - Processes have access permissions for the partitions 
    - Potentially shared between processes 
- Each process could have multiple partitions with different sizes and characteristics 
- In basic scheme, still only physical addresses (later we'll get to virtual addresses)
- Problems
    - Cannot relocate -> once a process has a partition, you can't easily move its contents elsewhere 
    - Not easily exapndable
    - Hard to support apps with larger address spaces than a physical memory 
        - Also can't support several applications whose total needs are greater than physical memory 
    - Also has fragmentation (dif type of it tho)

Relocation and expansion 
- Partitions are tied to particular address ranges, at least during an execution 
- Can't just move partition contents to another set of addresses 
    - All pointers in contents will be wrong 
    - Generally you don't know which memory locations contain pointers 
- Hard to expand because there may not be space “nearby”

Expansion problem 
- Partitions are allocated on request 
- Processes can ask for new ones later, but partitions that have been allocated can't be moved somewhere else in memory 
- Memory managetment system might have allocated to another process all the space after a given partition -> can't expand!

How to keep track of variable sized partitions? 
- Start with one large heap of memory 
- Maintain free list - to keep track of pieces of unallocated memory 
- When process requests more memory, find a large enough chunk of memroy, carve off piece of requestd size, put remainder back onto free list 
- When process frees memory, put freed memory back on free list 

Managing free lsit 
- Fixed sized blocks are easy to track with bit map indicating which blocks are free 
- Variable chunks need more info: linked list of descriptors, one per chunk at front of it 
    - size of chunk 
    - whether it's free 
    - pointer to next chunk of list
- Allocated memory may have descriptors too

[SEE IMAGE: free_list.png] 

External Fragmentation 
- Internal frag doesn't really happen, only when requestor asks for more than he will use (not problem of OS tho)
- External = Gradually build up small, unusable memory chunks scattered through memory -> too small to satisfy any reqeust 
- Solution: try not to make tiny fragments, or try to recombine fragments into big chunks 

How to avoid creating smol fragments? 
- Be smart about which free chunk of mmemory you use to serve request, but this shit is expensive 
- Some choices: 
    - Best fit = Search for the “best fit” chunk (smaller than or equal to)
        - Pro: Could find perfect fit  
        - Con: Look thru whole list every time, can quickly create smol shits 
    - Worst fit = Largest size greater than or equal to requested size
        - Pro: Creates very large fragments for a bit
        - Con: Still have to search whole list every time 
    - First fit = Just take first chunk that is big enough
        - Pro: short search, creates random sized fragments 
        - Con: First chunks fragment fast, searches become longer, pretty bad fragmentation like best fit 
    - Next fit = like first fit, but after every search set guess pointer to chunk after the one we chose, so that for the next request we start the search at that pointer instead of the top of the list
        - Pro: short searches, spreads out fragmentation like worst fit. 
        - save lots of time if guess pointers are right, still works if wrong.. can be used in wide range of problems 

Coalescing partitions = how to reassemble fragments to fight external fragmentation 
- Steps 
    – Check neighbors whenever a chunk is freed
    – Recombine free neighbors whenever possible
    – Free list can be designed to make this easier
- Opposes fragmentation in process -> which will dominate? 
- Coalescing works better with more free space 
- Chunks held for a long time cannot be coalesced 
- Highly variable requested chunk sizes increases fragmentation rate, predictable sizes are good 
- Framentation gets worse with time 

Variable size partition summary 
- Lowers internal frag 
- Expsnive because of long searches of free list, carving and coalescing 
- External frag is inevitable, fought by coalescing 

Why Aren’t Memory Request Sizes Randomly Distributed?
- In real systems, some sizes are requested much more often than others
- Many key services use fixed-size buffers
    – File systems (for disk I/O)
    – Network protocols (for packet assembly)
    – Standard request descriptors

Buffer pools 
- Popular size -> reserve special pools of fixed size buffers to satisfy matching requests from those pools 
- Benefit: improved efficiency 
    - Simpler than variable partition allocation bc eliminates searching, carving, coalescing 
    - Reduces / eliminates external fragmentation 
- We must know how much to reserve 
    - Too little -> buffer pool becomes bottleneck 
    - Too much -> lots of unused buffer space 
- Only satisfy perfectly matching requests. Otherwise, back to internal frag  

How to use buffer pool 
- Process requests a piece of memory for a special purpose
- System gives one element of buffer pool 
- Process uses it, completes, frees memory 
    - Explicitly 
    - Implicitly - based on how such buffers are used

Dynamically sizing buffer pool 
- Short on fixed sized buffers -> get more memory from free list, carve into more fixed sized buffers 
- Too many fixed sized buffers -> return some buffers to free list 
- Free list gets too low -> ask each major service w/ buffer pool to return space 
- Parameters: low space threshold, high space theshold, nominal allocation (what we free down to)
- Resulting system adapts to changing loads 

Lost memory 
- Memory leaks when process is done with memory but forgets to free it 
- Problem when a process manages its own memory space, e.g. it allocates big area and maintains its own free list 
- Long running processes with memory leaks are huge Ls 

Garbage collection - a solution to memory leaks 
- Don't count on processes to release memory 
- Monitor how much free memory we have 
- When low on memory, search data space to find every object pointer, note address/size of all accessble objects, computes complement (what is inaccessible), add all inacessible memory to free list 

How to find all accessible memory? 
- Object oriented languages can do this by tagging object references, including size info in object descriptors 
- Possible for system resources where all possible references are known, like open files 
- What about for general case? 

General GC 
- Find all pointers in RAM
- Determine how much memroy each pointer points to 
- Determine what is pointed to and what is no longer pointed to 
- Free what isn't pointed to 

Problemos with this 
- A location in the data or stack segment might seem to collect addresses, but...
    - Are they actually pointers or are they other data types whose values happen to resemble addresses? 
    - If pointers, are they themselves stlil accessible? We can infer this recursivly for pointers in dynamically allocated structures but what about in pointers in statically allocated areas? 

Compaction & relocation 
- Can stop accepting new allocations but processes needing more memory would block until some is freed, slowing the system
- How to re-arrange active memory? 
    - Re-pack all processes in one end of memory
    - Create one big chunk of free space at other end
- Relocation = ability to move a process's data from region where it was initially loaded into new and dif region of memory 
    - Hard because all addresses in program will be wrong 
        - References in code segment, calls and branches to other parts of code, references to variables in data segment 
        - New pointers created during execution that point into data and stack segments

Virtual address spaces 
??
