------------------------------------
SOFTWARE INTERFACE STANDARDS: http://htmlpreview.github.io/?https://github.com/markkampe/Operating-Systems-Reading/blob/master/interfaces.html
------------------------------------

interchangeability and interoperability = confidence that independently manufactured components will fit and work together

Challenges of Software Interface Standardization

- Standards
    - Pros:
        - Details gone over in detail 
        - Platform neutral between providers 
        - Clear specifications, good testing
        - Give suppliers freedom to explore implementations, as long as you conform to standard so it is usable 
    - Cons:
        - Contstrains freedom of implementation if new interfaces are not completely upwards compatible with old interfaces 
        - Constrains consumers with applications that must have the standard features 
        - Always a downside to a change for some people 

- Confusing interfaces with Implementations
    - Interface standards shoud not specify design. Interface specifies behavior in implementation-neutral way. Implementation neutrality hard because implementation solves problem. 
    - When interface specifications are written after product is shipped -> implementation might not work with interface 

- The rate of evolution, for both technology and applications
    - Demand for latest apps to work on old phone (obsolete), vs demand for old software to adapt to new products
    - Compromise between two options -> most common path 

Proprietary vs Open standards
- Proprietary = developed and controlled by a single organization
- Open standard = developed and controlled by a consortium of providers and/or consumers

- Companies come up with new tech, must decide to 
    - make open source -> open interface definitions to competitors ot make product better, more widely adopted 
        - give up control, competitive advantage 
    - keep proprietary -> maximize competitive advantage 
        - competing standard gets better -> we lose 
        - competition fragments market, lowers adoption 


APIs 

- Include:
    - included routines/methods and their signatures (parameters, return types)
    - associated macros, data types, data structures
    - semantics of each op, and how it should be used
    - all of options, what each does, and how should be used
    - return values and possible errors

- written at the source programming level (e.g. C, C++ , Java, Python)
- describe how code should be written to use features 
- specifications are a basis for software portability
- applications must be recompiled for each platform -> devs can recompile and execute correctly on any platform that supports the API; suppliers can write apps for APIs should port to their platform 

- platform independent API: will work with machines with different types, endian-ness, feature implmentations on platforms 



ABIs = the binding of an API to an ISA

- Don't have source code of software -> download program and run it 
- Executable programs compiled for particular ISA and OS 
- Need program to run on any phone or OS..

- API = defines subroutines, what they do, and how to use them
- ABI = machine language instructions and conventions that are used (on a particular platform) to call routines

- Contains:
    - binary representation of key data types
    - instructions to call to and return from a subroutine
    - stack-frame structure and respective responsibilities of the caller and callee
    - how parameters are passed and return values are exchanged
    - register conventions (which are used for what, which must be saved and restored)
    - analogous conventions for system calls, and signal deliveries
    - formats of load modules, shared objects, and dynamically loaded libraries

- ABI more portable 
    - If an application is written to a supported API, and compiled and linkage edited by ABI-compliant tools, the resulting binary load module should correctly run, unmodified, on any platform that supports that ABI. 
    - As long as the CPU and Operating System support that ABI, there should be no need to recompile a program to be able to run it on a different CPU, Operating System, distribution, or release. --> can distribute binary versions of an app to many markets 

- Used by compiler (not programmer) to generate code, linkage editor to load modules, program loader to read modules into memory, OS to process system calls 



------------------------------------
Software Interface Standards: https://lasr.cs.ucla.edu/reiher/cs111/interfaces.html
------------------------------------

