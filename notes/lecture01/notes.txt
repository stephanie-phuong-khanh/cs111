------------------------------------------
LECTURE 1 (Thursday 10/01 & Tuesday 10/06)
------------------------------------------
An operating system is low level software that provides better abstractions of hardware below it, to allow easy, safe, fair use and sharing of these resources. 

Manages hardware by allocating and managing it, enforcing controlled sharing/privacy, oversees execution and error hadnles 
Abstracts hardware to make it usable and portable (program works on different machines) and performant
New abstractions for applications -> More powerful than just hardware 

Management + abstraction services
Applications see objects and their services
    CPU supports data types [bytes, shorts, longs, etc.] and operations [add, subtract, copy, etc.]
    OS supports (higher level) data structures [files, processes, threads, etc.] and operations [create, destroy, read, write, etc.]

Use system call when you want to use privieged instruction set. Want to do something private in OS -> must ask OS to do it. Mostly done by calling library that itself makes the system call. Or write assembly language. Application software cannot run a privileged instruction, will fail if it tries.

---> week 1 (Tuesday 10/06)

BIOS = firmware used to perform hardware initialization during the booting process
The OS is control of the hardware.
    Automatically loaded when machine boots 
    First sw to have access to hardware 
    Continues running when apps come and go 
Has complete hardware access 
    Privilged insn set, all of memory and I/O
Mediates application interaction with hardware 
Trusted 
If OS crashes, everything else on machine crashes 

Instruction set architecture (ISA)
- Set of instructions supported by a computer (bit pattern -> operation)
- Different ISAs 
    - Different word/bus widths (8, 16, 32, 64, bit)
    - Different features (low power, floating point, etc)
    - Different design philosophies (RISC vs CISC - complex,powerful instructions)
    - Competitive reasons (68000, x86, PowerPC)
- Usually come in families - Newer models add features but remain upwards comptible with older models
    - Families are versions 
    - Software that can run on old version can run on new version (upgrade is a feature not a problem)
    - If second machine has same architecture as first machine, OS can run on it. 

Privilged vs General(standard) instruction set 
- Most modern ISAs divide insns between these two types 
- Any code running on the machine can execute any of the general instructions 
- To execute Privilged instructions, processor must be put into a special mode 
    - Only in that mode when the OS is running 
    - Privilged insns do things that are "dangerous" in terms of (not) properly performing computations

Platform = collection of all the hardware you have on computer; OS = software 
- ISA doesn't completely define a computer 
    - Funcitonality beyond user mode instructions  
        - Interrupt controllers, DMA controllers
        - Memory management unit, I/O busses 
        - BIOS, configuration, diagnsotic features 
        - Multi processor and interconnect support 
    - I/O devices: display, disk, network, serial device controllers
- Platform on which OS runs

Portability to Multiple ISAs 
- Successful OS will run on many ISAs 
    - Some customers cannot choose their ISA 
    - If you don't support it, you can't sell to them 
- OS needs to abstract away the ISA 
- Minimal assumptions about specific hardware 
    - General frameworks are HW independent: file systems, protocols, processes, etc 
    - HW assumptions isolated to specific moduels: context switching, I/O, memory management 
        e.g. can't treat flash drive like rotating disk drive -> need software that treat these two differently 
    - Careful use of types: word length, sign extension, byte order, alignment 
-> How can an OS manufacturer distribute to all these different ISAs and platforms? 

Use the BINARY DISTRIBUTION MODEL 
- Binary code is the derivative of source 
    - OS is written in source code (C)
    - but source code needs to be compiled (machine language is specific to ISA)
    - Binary distribution is ready to run (1 binary distribution for every ISA)
- OSes usually distributed in binary 
- One binary distribution per ISA
- What about platform (different machines) problem? 
    - Customize OS to fit the platform (e.g. behave according to amount of memory available)
    - Binary model for platform support 
        - Device drivers can be added after market, written/distirbuted by 3rd parties
        - Same driver works with many versions of OS 

Binary configuration model
- Good to eliminate manual/static configuration
    - Enable one distribution to serve all users 
    - Improve both ease of use and performance 
- Automatic hardware discovery (BIOS starts up OS, OS figures out what hardware we have)
    - Self identifying busses
        - Bus is HW device that connects all hardware (most important: CPU to RAM)
    - Automatically find and load required drives
- OS does automatic resource allocation 
    - Eliminate fixed sized resource pools 
    - Dynamically (re)allocate resources on demand 

What funcitonality is in the OS?
- As much as necessary, as little as possible 
    - OS code is very expensive to develop and maintain 
- Functionality must be in the OS if it..
    - Needs to use privileged insturctions 
    - Needs to manipulate OS data structures 
    - Needs to maintain security, trust, resource integrity 
- Functions should be libraries if they ...
    - are a service commonly needed by applications 
    - do not actually have to be implemented inside the OS 
- But there is also the performance excuse since some things are faster if done in OS 
    - Often, if something that doesn't have to be done in OS is moved into OS anyways

OS and abstraction
- Offers abstract versions of resources as opposed to actual physical resources 
- OS implements abstract resources using physical resources 
    - process (abstraction) are implemented with CPU and RAM (physical)
    - files (abstraction) are implemented with disks (physical)

Why abstract resources? 
- Abstractions are simpler to use for programmers and users 
    - Easier to use than the original resources
    - Compartmentalize and encapsulate complexity 
    - Eliminate behavior irrelevant to user - e.g. slow erase cycle of flash memory 
    - Create more convenient behavior - make it seem like you have entire resource to yourself 

General abstractions 
- Many variations in machines' hardware and software 
- Make many different types appear the same -> applications can deal with single common class 
- Usually involves a common unifying model 
    - portable document format (pdf) for printers 
    - SCSI standard for disks, CDs and tapes 
- e.g. printer drivers make different printers look the same; browser plug-ins to handle multi-media data 

Common types of OS resources 
(1) Serially reusable resources 
    - used by multiple clients, but only one at a time (time multiplexing)
    - require access control to ensure exclusive use 
    - require graceful transitions from one user to the next 
        - a switch taht totally hides the fact that the resource that used to belong to someone else 
        - don't allow second user to access resource until first user is done (no incomplete ops that finish after the transition)
        - make sure each subsequent user finds the resource in "like new" condition 
    - e.g. printer, speakers, toilets
(2) Partitionable resource
    - divided into disjoint pieces for multiple clients - spacial multiplexing 
    - needs access conrol to ensure: 
        (a) Containment - you cannot access resources outside of your partition 
        (b) Privacy - nobody else can access resources in your partition 
    - e.g. RAM, hotel (rooms)
    - Still need graceful transitions because partitionable resources mostly are not permanently allocated - the piece of RAM i'm using now will belong to anohter process later 
        - as long as it's mine, no transition required 
        - but sooner or later it's likely to become someone else's 
    - CPU with multiple cores is partitionable resource, each core is serially reusable 
(3) Shareable resources 
    - Usable by multiple concurrent clients 
        - Clients don't wait for access to resource
        - Clients don't own a particular subset of the resource 
    - may involve (effectively) limitless resources 
        - Air in a room, shared by occupants 
        - Copy of the OS, shared by processes (no separate copy of OS for each process)
    - Do we still need graceful transitions? 
        - Typically not 
        - Shareable resource usually doesn't change state 
        - or it isn't "reused"
        - we never have to clean up what doesn't get dirty  (like execute-only copy of OS)
        - design your system to maximize sharable resource!

General OS trends 
- They have grown larger and more sophisticated 
- Their role has fundamentally changed 
    - From shepherding the use of the hardware 
    - To shielding the applications from the hardware 
    - To provide powerful application computing platform 
    - To become a sophisticated "traffic cop" 
- They still sit between applications and hardware 
- Best understood through services they provide 
    - Capabilities they add 
    - Applications they enable 
    - Problems they eliminate 

Why? 
- It's what users want 
- OS must provide core services to applications 
- Applications have become more complex 
    - More complex internal behvaior 
    - More complex interfaces 
    - More interactiosn with other software 
- OS needs to help with all that complexity 

OS convergence 
- There are a handful of widely used OSes:
    - Windows
    - MacOS - built on UNIX 
    - Linux 
        - ChromeOS is linux
- Special purpose ones 
    - real time - control things in real world at particular schedule 
    - embedded system - put OS in physical device for that device's function, not general computing 
- OSes in the same fam are used for vastly different purposes 
    - Challenging for OS designer 
- Most OSes are based on pretty old models

Conclusion: the OS ...
- interacts directly with the hardware
- provide services via abstractions
- are constrained by many non-technical factors - business reasons for there being 3 main OSes 